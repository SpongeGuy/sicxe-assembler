FINAL PROJECT REPORT

OPCODE_TABLE
	stores the opcode for each mnemonic instruction as well as the format of each instruction

REG_VALUES
	stores the values for each register

DIRECTIVES
	holds the mnemonic phrases for each assembler directive

SYMBOL_TABLE
	a table which stores symbols and their addresses found in memory in the format (generated during first pass)
	(ADDRESS, NAME, FLAGS, PROGRAM_BLOCK_ID, CONTROL_SECTION_ID)

CONTROL_SECTION_ID
	an integer value used to store the current control section

WORKING_LITERAL_TABLE
	a counterpart to the LITERAL_TABLE which acts as a stack to store literals so that they can be popped out of the table (and translated into decipherable code) during the first pass of the assembler

LITERAL_TABLE
	stores all literals found in the source code in the format
	[ADDRESS, LITERAL_VALUE, PROGRAM_BLOCK_ID, CONTROL_SECTION_ID]
	this format is the same for the WORKING_LITERAL_TABLE but literals in this table are appended at the end of the table rather than inserted at the beginning

EXTREFS
	stores external references found in the source code in the format
	(LIST OF LABELS, CONTROL_SECTION_ID)

MACROS
	stores macros found in the source code. generated before the first pass. macros are stored in the format
	[NAME, BODY, PARAMETERS]

LOCCTR
	location counter variable. used to assign memory locations to statements in source code. set to whichever operand is present in the 'START' command at the beginning of each program/control section

LOCATION_COUNTERS
	used to store different location counters for unique program blocks. counters are stored in the format
	[NAME, PROGRAM_BLOCK_ID, STARTING_ADDRESS, LENGTH, ACTIVE]
	where ACTIVE is used as a boolean switch to determine which location counter to increment during pass one.
	STARTING_ADDRESS is set after pass one.

ACTIVE_LOCCTR_ID
	an integer value used to store the current program block

sample
	the path for the assembly file to load and translate into object code

get_instruction_data_length(instruction_data)
	grabs an integer value which reflects the length of the instruction based on the statement parameter. this value can be used to increment the location counter.

get_next_address(instruction_data)
	a helper function which should probably be merged into get_instruction_data_length() because it serves no purpose other than to have a try except block inside of it

parse_instruction(instruction)
	strips a string of its contents besides '+' character and [A-Z] characters

get_literal_code(literal)
	takes in a literal value and returns its object code according to sic/xe rules

update_symbol_table(instruction_data)
	takes in a line of code and determines if the SYMBOL_TABLE needs to be appended with the label and address of the line

update_literal_table(statement)
	reads a statement and determines if the operand is in the literal table. if not, the operand gets appended to the literal table and the operand within the statement gets changed to the id of the literal for second pass.

get_literal_length(literal_match)
	takes a literal and returns its length according to sic/xe rules.

get_literal_pool(statement)
	this is called after every LTORG directive or at the end of the program. assigns all literals still in the WORKING_LITERAL_TABLE a value in memory.

generate_macro_instruction_data(statement, macro)
	runs before first pass. takes a statement (representing a macro invokation) and macro rule from the MACROS table and iterates through the body of the macro, replacing the parameters found in the body of the macro with the parameters defined in the statement.
	returns a table of raw statements (identical to statements found at the beginning of first_pass()).

do_macros()
	takes the entire assembly file and determines if there are macro invokations in the file. if there are, then replace each macro invokation with the proper macro body generated using generate_macro_instruction_data(). 
	returns a table of raw statements to be passed through the assembler.

update_location_counters(statement)
	uses some basic logic to determine which program block is currently being worked in, if the program block is being changed (by looking at the statement), and if there needs to be any changes to the LOCATION_COUNTERS table.

first_pass(finished_file)
	takes in the table of raw statements generated by do_macros(). here, SYMBOL_TABLE, LITERAL_TABLE, EXTREFS, WORKING_LITERAL_TABLE, LOCATION_COUNTERS, etc. are used to do several operations on each line found in finished_file to generate an intermediate file which is used during the second pass to generate object code.

second_pass(intermediate_file)
	iterates through intermediate_file and uses some logic to generate object code for each statement in the source code.

set_base_register(statement)
	refers to statement and determines if base register value needs to be updated. if so, then update accordingly

parse_operand(operand)
	ensures that no strange characters are in the operand for statements in second_pass()

wrap_4bit_hex(negative_hex)
	used to generate proper object code for statements whose displacement value is negative

generate_obj_code(statement, intermediate_file)
	takes a statement and the intermediate_file generated during the first pass to generate object code for each statement found in the intermediate file. this is the bulk of operations done during the second pass.


-- report --
I am not very good at taking notes from books and putting together a grand plan from my notes, so this project was a bit like me running around like a chicken with its head chopped off. As a result of not having a very concrete plan of action for the project, I encountered difficulties nearly every time I needed to add functionality to process a new assembly file. Also, I was not able to add the functionality of generating modification records, which is essential for an assembler to generate so a loader can successfully load the program.
By far, literals were the hardest to understand for me; it took days of research inside the book to actually wrap my head around literals and to understand how to process them during the first pass of the assembler so the second pass can accurately generate machine code. Multiple tables were needed to accomplish an accurate generation of object code for statements which use literals.
The most fun part of the project was probably building the second pass of the assembler. I think it's fascinating the way assembler generate code and it was immensely satisfying to finish generating machine code for functions.txt. At that point, I was mostly ignorant about the trouble that would come in the future.
Overall, I now know that doing projects like these alone is a huge mistake. I could not have finished what I have finished without my friend Austin who has good intuitive knowledge about low-level computing. Also, doing huge projects like these without a concrete plan is also a mistake. A good amount of my time should have been looking through the book for all the functionality I would need to create the assembler, take notes on each part, and create a document which would facilitate the creation of the assembler.